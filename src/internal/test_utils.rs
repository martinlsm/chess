#[cfg(test)]
pub mod fen {
    use itertools::izip;

    use crate::{error::chess_error, Result};

    /// Bitfield-based type that specifies which space-separated fields of FEN formats to compare
    pub type FenComparator = u32;
    /// Compare the position of the pieces
    pub static CMP_POS: FenComparator = 1 << 5;
    /// Compare the side to move
    pub static CMP_SIDE_TO_MOVE: FenComparator = 1 << 4;
    /// Compare possibilities to castle
    pub static CMP_CASTLING: FenComparator = 1 << 3;
    /// Compare en passant
    pub static CMP_EN_PASSANT: FenComparator = 1 << 2;
    /// Compare halfmove clock (50 move rule)
    pub static CMP_HALFMOVE_CLOCK: FenComparator = 1 << 1;
    /// Compare fullmove counter (Incremented after each Black's move)
    pub static CMP_FULLMOVE_COUNTER: FenComparator = 1 << 0;
    /// Compare all fields
    pub static _CMP_ALL: FenComparator = CMP_POS
        | CMP_SIDE_TO_MOVE
        | CMP_CASTLING
        | CMP_EN_PASSANT
        | CMP_HALFMOVE_CLOCK
        | CMP_FULLMOVE_COUNTER;

    pub fn compare_fen(fen_lhs: &str, fen_rhs: &str, comparator: FenComparator) -> Result<bool> {
        for (i, p1, p2) in izip!(0.., fen_lhs.split(" "), fen_rhs.split(" ")) {
            if i >= 6 {
                return Err(chess_error(&format!(
                    "Comparing invalid FEN formats ({} and {})",
                    p1, p2
                )));
            }

            // Check if this space-separated specified should be compared
            if comparator & (1 << i) != 0 && p1 != p2 {
                return Ok(false);
            }
        }

        Ok(true)
    }
}

#[cfg(test)]
pub mod json {
    use serde::Deserialize;

    use crate::board::Board;
    use crate::error::chess_error;
    use crate::square::Square;
    use crate::{fen, Result};

    use std::fs::File;
    use std::io::{BufReader, Read};

    use super::fen::compare_fen;

    #[derive(Deserialize)]
    struct TestCases {
        description: Option<String>,
        testcases: Vec<TestCase>,
    }

    #[derive(Deserialize)]
    struct TestCase {
        start: Start,
        num_valid_moves: Option<usize>,
        expected: Option<Vec<Expected>>,
    }

    #[derive(Deserialize)]
    struct Start {
        description: Option<String>,
        fen: String,
    }

    #[derive(Deserialize)]
    struct Expected {
        #[serde(alias = "move")] // move is a reserved keyword; therefore, alias it
        mov: String,
        fen: String,
    }

    fn import_test(file_path: &str) -> Result<TestCases> {
        let file = File::open(&file_path)?;
        let mut buf_reader = BufReader::new(file);

        let mut content = String::new();
        buf_reader.read_to_string(&mut content)?;

        let test_cases: TestCases = serde_json::from_str(&content)?;

        Ok(test_cases)
    }

    fn str_to_bitfield<
        T: Default
            + From<char>
            + std::ops::Add<Output = T>
            + std::ops::Shl<usize, Output = T>
            + std::ops::Add<T, Output = T>,
    >(
        bits: &str,
    ) -> Result<T> {
        let num_bits = bits.len();
        let max_num_bits = std::mem::size_of_val(bits) * 8;
        if num_bits > max_num_bits {
            return Err(chess_error(&format!(
                "Input is too long ({} > {})",
                num_bits, max_num_bits
            )));
        }
        if !bits.chars().all(|bit| bit == '0' || bit == '1') {
            return Err(chess_error(&format!("All bits must be ones or zeros")));
        }

        Ok(bits
            .chars()
            .enumerate()
            .map(|c| T::from(c.1) << (num_bits - c.0))
            .fold(T::default(), |a, b| a + b))
    }

    pub fn run_check_num_moves_test(json_file_path: &str) -> Result<()> {
        let test_cases = import_test(json_file_path)?;
        let test_cases_description = test_cases
            .description
            .clone()
            .unwrap_or(String::from("Unnamed test cases"));

        for test_case in &test_cases.testcases {
            let test_case_description = test_case
                .start
                .description
                .clone()
                .unwrap_or(String::from("Unnamed test case"));

            let expected_num_moves = test_case.num_valid_moves.ok_or(chess_error(
                "Test case file is missing the field \"num_moves\"",
            ))?;

            // Store a list of all possible moves generated by the SUT
            let mut board: Board = fen::import(&test_case.start.fen)?;
            let poss_moves = board.gen_moves();
            let num_poss_moves = poss_moves.len();

            assert_eq!(num_poss_moves, expected_num_moves, "Test case \"{test_case_description}\" of test suite \"{test_cases_description}\" failed");
        }

        Ok(())
    }
}
