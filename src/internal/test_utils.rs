#[cfg(test)]
pub mod fen {
    use itertools::izip;

    use crate::{error::chess_error, Result};

    /// Bitfield-based type that specifies which space-separated fields of FEN formats to compare
    pub type FenComparator = u32;
    /// Compare the position of the pieces
    pub static CMP_POS: FenComparator = 1 << 5;
    /// Compare the side to move
    pub static CMP_SIDE_TO_MOVE: FenComparator = 1 << 4;
    /// Compare possibilities to castle
    pub static CMP_CASTLING: FenComparator = 1 << 3;
    /// Compare en passant
    pub static CMP_EN_PASSANT: FenComparator = 1 << 2;
    /// Compare halfmove clock (50 move rule)
    pub static CMP_HALFMOVE_CLOCK: FenComparator = 1 << 1;
    /// Compare fullmove counter (Incremented after each Black's move)
    pub static CMP_FULLMOVE_COUNTER: FenComparator = 1 << 0;
    /// Compare all fields
    pub static _CMP_ALL: FenComparator = CMP_POS
        | CMP_SIDE_TO_MOVE
        | CMP_CASTLING
        | CMP_EN_PASSANT
        | CMP_HALFMOVE_CLOCK
        | CMP_FULLMOVE_COUNTER;

    pub fn compare_fen(fen_lhs: &str, fen_rhs: &str, comparator: FenComparator) -> Result<bool> {
        for (i, p1, p2) in izip!(0.., fen_lhs.split(" "), fen_rhs.split(" ")) {
            if i >= 6 {
                return Err(chess_error(&format!(
                    "Comparing invalid FEN formats ({} and {})",
                    p1, p2
                )));
            }

            // Check if this space-separated specified should be compared
            if comparator & (1 << i) != 0 && p1 != p2 {
                return Ok(false);
            }
        }

        Ok(true)
    }
}

#[cfg(test)]
pub mod json {
    use serde::Deserialize;

    use crate::board::Board;
    use crate::error::chess_error;
    use crate::square::Square;
    use crate::{fen, Result};

    use std::fs::File;
    use std::io::{BufReader, Read};

    use super::fen::compare_fen;

    #[derive(Deserialize)]
    struct TestCase {
        description: Option<String>,
        comparator: String,
        start: String,
        expected: Vec<Destination>,
    }

    #[derive(Deserialize)]
    struct Destination {
        #[serde(alias = "move")] // move is a reserved keyword; therefore, rename and alias it
        mov: String,
        fen: String,
    }

    fn import_test(file_path: &str) -> Result<TestCase> {
        let file = File::open(&file_path)?;
        let mut buf_reader = BufReader::new(file);

        let mut content = String::new();
        buf_reader.read_to_string(&mut content)?;

        let test_cases: TestCase = serde_json::from_str(&content)?;

        Ok(test_cases)
    }

    fn str_to_bitfield<
        T: Default
            + From<char>
            + std::ops::Add<Output = T>
            + std::ops::Shl<usize, Output = T>
            + std::ops::Add<T, Output = T>,
    >(
        bits: &str,
    ) -> Result<T> {
        let num_bits = bits.len();
        let max_num_bits = std::mem::size_of_val(bits) * 8;
        if num_bits > max_num_bits {
            return Err(chess_error(&format!(
                "Input is too long ({} > {})",
                num_bits, max_num_bits
            )));
        }
        if !bits.chars().all(|bit| bit == '0' || bit == '1') {
            return Err(chess_error(&format!("All bits must be ones or zeros")));
        }

        Ok(bits
            .chars()
            .enumerate()
            .map(|c| T::from(c.1) << (num_bits - c.0))
            .fold(T::default(), |a, b| a + b))
    }

    pub fn run_test(json_file_path: &str) -> Result<()> {
        let test_case = import_test(json_file_path)?;
        let description = test_case
            .description
            .clone()
            .unwrap_or(String::from("Unnamed test case"));
        let fen_cmptor = str_to_bitfield(&test_case.comparator)?;

        // Store a list of all possible moves generated by the SUT
        let board: Board = fen::import(&test_case.start)?;
        let poss_moves: Vec<(Square, Square)> = board.gen_moves();
        let mut fens_after_moves: Vec<String> = Vec::new();
        for (from, to) in &poss_moves {
            let mut board_copy = board.clone();
            board_copy.move_piece(from, to)?;
            let fen = fen::export(&board);
            fens_after_moves.push(fen);
        }

        assert_eq!(poss_moves.len(), test_case.expected.len());

        for dest in test_case.expected.iter() {
            assert!(
                fens_after_moves
                    .iter()
                    .any(|fen| compare_fen(&dest.fen, fen, fen_cmptor).unwrap_or(false)),
                "{} failed",
                description
            );
        }

        Ok(())
    }
}
